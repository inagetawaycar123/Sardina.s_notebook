---
date: 2025-11-29
tags:
  - 排序
  - C语言
aliases:
  - Merge Sort
---
```c
extern void MergeSort(int *array, int length){
    int *a = array;
    int *b = malloc(length * sizeof(int));
    for(int seg = 1; seg < length; seg += seg){
        for(int start = 0; start < length; start += 2*seg){
            int head = start, mid = minf(start + seg, length),
            end = minf(start + 2*seg, length);
            int k = head;
            int lt1 = head, lt2 = mid, rt1 = mid, rt2 = end;
            while(lt1 < rt1 && lt2 < rt2){
                b[k++] = a[lt1] < a[lt2] ? a[lt1++] : a[lt2++];
            }
            while(lt1 < rt1){
                b[k++] = a[lt1++];
            }
            while(lt2 < rt2){
                b[k++] = a[lt2++];
            }
        }
        int *temp = a;
        a = b;
        b = temp;
    }
    if(a != array){
        for(int i = 0; i < length; i++){
            a[i] = b[i];
        }
    }  
    free(b);
}
```

归并排序感觉本来不写代码理解起来就不容易，写起来更难:

假设有一个待排序的列表 \[38, 27, 43, 3, 9, 82, 10]，归并排序的过程如下：

1. **分解**：
    - 将列表分成两半：`[38, 27, 43, 3]` 和 `[9, 82, 10]`。
        
    - 继续分解：
        - `[38, 27, 43, 3]` 分成 `[38, 27]` 和 `[43, 3]`。
        - `[9, 82, 10]` 分成 `[9]` 和 `[82, 10]`。
    - 继续分解：
        - `[38, 27]` 分成 `[38]` 和 `[27]`。
        - `[43, 3]` 分成 `[43]` 和 `[3]`。
        - `[82, 10]` 分成 `[82]` 和 `[10]`。
    - 最终分解为单个元素的子列表。
        
2. **合并**：
    
    - 合并 `[38]` 和 `[27]` 得到 `[27, 38]`。
    - 合并 `[43]` 和 `[3]` 得到 `[3, 43]`。
    - 合并 `[27, 38]` 和 `[3, 43]` 得到 `[3, 27, 38, 43]`。
    - 合并 `[9]` 和 `[10, 82]` 得到 `[9, 10, 82]`。
    - 合并 `[3, 27, 38, 43]` 和 `[9, 10, 82]` 得到最终有序列表 `[3, 9, 10, 27, 38, 43, 82]`。

Tips：
1. 如果合并的过程中其中一半已经结束，直接按顺序接另一半剩下的元素
2. 对`a`合并的结果储存在`b`，对`b`处理的结果又去到`a`，所以一方面每一次处理要调换`a`与`b`的“谁被处理”位置，另一方面最终结果`a`必须是顺序正确的数组