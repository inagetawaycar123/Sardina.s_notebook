---
date: 2025-11-25
tags:
  - C语言
  - 排序
aliases:
  - Insertion Sort
---
```c
extern int* InsertionSort(int* array, int length){
    int* head = array;
    for(int i = 1; i < length; i++){
        int temp = array[i];
        int j = i - 1;
        while(j >= 0 && array[j]>temp){
            array[j+1] = array[j];
            j--;
        }
        array[j+1] = temp;
    }
    return head;
}```

**虽然短短几行，却藏了几百个心眼子，大概这就是数学吧。**
#### （1）外层 for 循环：遍历未排序区间

- `for(int i = 1; i < length; i++)`：
    - 初始假设：数组第 1 个元素（`array[0]`）是 “已排序区间”（只有 1 个元素，天然有序）；
    - `i` 从 1 开始，依次取 “未排序区间” 的第一个元素（`array[i]`），作为当前要插入的元素。

#### （2）内层 while 循环：找到插入位置并移动元素

- `int temp = array[i]`：暂存当前要插入的元素（避免后续移动元素时被覆盖）；
- `int j = i - 1`：`j` 指向 “已排序区间” 的最后一个元素（初始是 `i-1`）；
- `while(j >= 0 && array[j] > temp)`：
    - 条件 1：`j >= 0`：确保不越界（已排序区间遍历完）；
    - 条件 2：`array[j] > temp`：升序逻辑 —— 如果已排序元素比当前元素大，就需要向后移动；
    - 循环体：`array[j+1] = array[j]`（将大元素向后挪一位），`j--`（继续向前遍历已排序区间）。

#### （3）结尾处理：在正确的位置插入

- `array[j+1] = temp;`：
	- `array[j]`是第一个小于原数的数，那么待插入的数自然放在它的后面，因此是`j+1`；
	- 待插入的数是最小的数，那么循环结束后`j`的值为-1，将数组中第一个数改成待插数。


**时间复杂度：$O(n^2)$**